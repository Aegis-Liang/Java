1. At first I don't know what is the order to insert to red-black tree, and red-black tree requires the key and value.
   These make me so confusing, finally I tried input the whole Point2D as key could work fine, and the Point2D has default comparable interface.

2. for(Point2D p : this.rb.keys(lo, hi))
       if(p.x()>=rect.xmin() && p.x()<=rect.xmax()&& p.y()>=rect.ymin()&& p.y()<=rect.ymax())
            stack.push(p);

   This part need to verify whether each point is in the rectangle, otherwise all Point2D ymin <= y <= ymax is considered
   in the rectangle since the comparable of Point2D is consider y axis first.

3. private RectHV rect;    // the axis-aligned rectangle corresponding to this node

   The comment has a little hard to understand, my preliminary understanding for the rect is correct but my data
   structure is hard to be implemented and manipulated because I thought the Node is based on the Point but it's
   actually based on the Rectangle. Once a point is inserted, the rectangle is divided to 2 pieces, each piece is
   a new rectangle for the left node or right node.

   private static class Node {
      private Point2D p;      // the point
      private RectHV rect;    // the axis-aligned rectangle corresponding to this node
      private Node lb;        // the left/bottom subtree
      private Node rt;        // the right/top subtree
   }

4. Based on last item, consider once a point is added, the point will split the rectangle into 2, and:
    1) Calculate these 2 rectangles and store them to lb and rt Node? But what about lb and rt's point2D? Null? Trouble...
    2) Calculate the rectangle When insert the point2D. This seems to be sensible, so the Node is still based on the Point2D.
       The data structure seemed to be not hard to implement that construct it when do the insert() because you have the
       parent's information.

5. This is the code for contains() function, very tricky for go through the tree and return the root, this may some
   kind of use in Red-Black tree, I don't very understand the mechanism at that time.

       public boolean contains(Point2D p)            // does the set contain point p?
       {
           return this.get(this.root, p, 0)!= null;
       }

       private Point2D get(Node x, Point2D p, int level)
       {
           if (x==null) return null;
           if (x.p.equals(p)) return p;
           if (level % 2 == 0) {
               if (p.x() < x.p.x())
                   return get(x.lb, p, level+1);
               else
                   return get(x.rt, p, level+1);
           }
           else
           {
               if (p.y() < x.p.y())
                   return get(x.lb, p, level+1);
               else
                   return get(x.rt, p, level+1);
           }
       }

6. range() function:
   Basic idea of it is to check whether the current point is in the rectangle, and check whether the whole rectangle
   in on side of current point based on the level of current point, if yes then we can skip other side's search and
   save have time.

7. nearest() function:
   The implementation of this function is tricky, we can have 3 variables first, distance between current point and
   query point(d1), distance between the nearest point in query point side and query point (d2, this variable is get from
   recursion), distance between the line generated by current point's level and query point (d3).
   If  d2 is larger than d3, that means the points in other side could have a chance that get closer than the points in
   d2, so in the case we search the points in other side. If d2 is not larger than d3, we skip searching in other side,
   this will save us half of the time.
   After getting all distance, we return the nearest point.

8. Test 1c: insert distinct points; check size() and isEmpty() after each insertion
     * 1 random distinct points in a 1-by-1 grid
     * 10 random distinct points in a 8-by-8 grid
     * 20 random distinct points in a 16-by-16 grid
     * 10000 random distinct points in a 128-by-128 grid
     * 100000 random distinct points in a 1024-by-1024 grid


   WARNING: the time limit of 180 seconds was exceeded, so not all tests could be completed.

   This seems like I cannot use recursion in size() function like this:

    public int size()                             // number of points in the set
    {
        if(this.root == null)
            return 0;
        return size(this.root);
    }

    private int size(Node x) {
        if (x == null) return 0;
        else return 1 + size(x.lb) + size(x.rt);
    }

    I have to do some size addition when insert to a null node.

9. Test 1d: insert general points; check size() and isEmpty() after each insertion
     * 5 random general points in a 1-by-1 grid
       - failed after inserting point 5 of 5
       - student   size()    = 5
       - reference size()    = 4
       - student   isEmpty() = false
       - reference isEmpty() = false
       - sequence of points inserted:
         A  1.0 0.0
         B  1.0 1.0
         C  0.0 0.0
         D  0.0 1.0
         E  1.0 0.0

     * 10 random general points in a 4-by-4 grid
       - failed after inserting point 4 of 10
       - student   size()    = 4
       - reference size()    = 3
       - student   isEmpty() = false
       - reference isEmpty() = false
       - sequence of points inserted:
         A  0.75 0.5
         B  1.0 0.0
         C  0.0 0.75
         D  1.0 0.0

     * 50 random general points in a 8-by-8 grid
       - failed after inserting point 12 of 50
       - student   size()    = 12
       - reference size()    = 11
       - student   isEmpty() = false
       - reference isEmpty() = false
       - sequence of points inserted:
         A  0.625 0.5
         B  0.0 0.875
         C  0.875 0.375
         D  0.25 0.125
         E  0.5 0.5
         F  0.5 0.75
         G  1.0 1.0
         H  0.5 0.625
         I  0.75 0.75
         J  0.125 0.375
         K  0.75 0.0
         L  0.0 0.875

    After observation, it seems that when they did skipping when inserting a same point, but I still insert it, so that
    the size are different.

10. Test 3c: insert distinct points; check range() with random query rectangles
      * 2 random distinct points and random rectangles in a 2-by-2 grid
      * 10 random distinct points and random rectangles in a 4-by-4 grid
        - failed on trial 1 of 10000
        - query rectangle = [0.5, 1.0] x [0.0, 1.0]
        - sequence of points inserted:
          A  1.0 0.75
          B  0.75 0.75
          C  0.75 0.5
          D  0.25 0.75
          E  0.75 1.0
          F  0.5 0.5
          G  0.25 0.25
          H  1.0 0.25
          I  0.25 1.0
          J  0.25 0.5
        - student   range():  E F C B A
        - reference range():  A B C F E H

    It seems that the sequence is reverse since I use stack, I also miss one item.
    After replace the stack with queue, the "10 random distinct points and random rectangles in a 4-by-4 grid" pass,
    it's weird. And 1k is fail, problem still exists, and found no way to check.

    Solving problem 11 could solve the 1k random distinct points fail issue. This means my wheel making capability is
    still low. :(  |_|!

11. Description:
     Goal. Find all points in a query axis-aligned rectangle.
    ・Check if point in node lies in given rectangle.
    ・Recursively search left/bottom (if any could fall in rectangle).
    ・Recursively search right/top (if any could fall in rectangle).

    That's why it need call the intersects() and contains() function of RectHV. It check the whether the rectangles
    intersect first.

12. Test 6a: insert points from file; check nearest() with random query points
             and check traversal of kd-tree
      * input5.txt
        - failed on trial 1 of 1000
        - performs incorrect traversal of kd-tree during call to nearest()
        - sequence of points inserted:
          A  0.7 0.2
          B  0.5 0.4
          C  0.2 0.3
          D  0.4 0.7
          E  0.9 0.6
        - query point                   = (0.92, 0.37)
        - student   nearest()           = (0.9, 0.6)
        - reference nearest()           = (0.9, 0.6)
        - student   distanceSquaredTo() = 0.0533
        - reference distanceSquaredTo() = 0.0533
        - student sequence of kd-tree nodes involved in calls to distanceSquaredTo():
          empty
        - reference sequence of kd-tree nodes involved in calls to distanceSquaredTo():
          A E B C D

    Point2D also has function about distance implemented.
    Try a hard way to modify the code. At the beginning I don't want to store the nearest point and its distance since
    this point will be updated dynamically and it seems this is not a regular way. But afterward I implement it I found
    the answer get closer even it's still scores 82.

    A lot of thing are modified here:
    1) Use a global variable to store the information of nearest point and the distance to query point.
    2) Need to update the information and distance of input node once the recursive nearest() function is called.
       Otherwise the comparison use the data out of date.
    3) There is a big modification on recursive nearest() function since nearest point is introduced.
       So we have update the process like below:
       A) Calculate the distance of the point of input node, update the nearest information if input point is nearest.
       B) Determine the side of query point, recursively get the closed point in this area, update the nearest information.
       C) If the distance from query point to rectangle of other side is closer than nearest point, that mean the points
          in this area have chances get closer than the nearest point, so we recursively go through this rectangle.
       D) Compare the nearest point, the point of input node, the point from query area and the point from other side,
          return the one closest to query point.

13. Timing KdTree
    *-----------------------------------------------------------
    Running 28 total tests.


    Test 1a-d: Insert n points into a 2d tree. The table gives the average number of calls
               to methods in RectHV and Point per call to insert().

                                                                                                    Point2D
                   n      ops per second       RectHV()           x()               y()             equals()
    ----------------------------------------------------------------------------------------------------------------
    => FAILED   160000     250362              22.6  (11.3x)     33.2              31.7              21.6
    => FAILED   320000     573292              23.0  (11.5x)     33.8              32.3              22.0
    => FAILED   640000     338686              24.5  (12.3x)     36.1              34.6              23.5
    => FAILED  1280000     374205              26.6  (13.3x)     39.2              37.7              25.6
    ==> 0/4 tests passed

    After searching in forum, the problem is about the time we called RectHV(), the number in parenthesis means you call
    this function x times more than you should call. For example, "22.6  (11.3x)" means you should call 2 times, but you
    actually call 22.6 times, that's 11.3x times more than you should call.

    In the insert() function, I new a rect and pass it to next recursive call, but if node in the call is not null,
    I new a rect with input rect again, this is unreasonable. Actually I can use the rect and just modify it and pass
    it to next recursive call, no need to new another one. Thanks for the grader could check for it! I think it's a
    very good method to test the function with such a table.

    RectHV doesn't provide any function or property to modify the xmin, ymin, xmax, ymax, and they are final variables  -_-!!!
    I can just pass the xmin, ymin, xmax, ymax to recursive call to avoid new a RectHV object, but is it proper way to
    do this?

    How can I forget that the rect is there is the x.lb or x.rt is not null? We can use it very effectively.
    If x.lb or x.rt is not null, we can pass the rect to next recursive call, and next call will drop if useless.
    If x.lb or x.rt is null, new a rect and pass to next recursive call.
    This problem is very tricky, how is possible that the instructor could come out this kind of optimization. Amazing!

    Change:

    private Node insert(Node x, Point2D p, RectHV rect, int level) {
        if (x == null) {
            this.size++;
            return new Node(p, rect, null, null);
        } else {
            if (p.equals(x.p))
                return x;
            if (level % 2 == 0) {
                if (p.x() < x.p.x()) {
                    x.lb = insert(x.lb, p, new RectHV(rect.xmin(), rect.ymin(), x.p.x(), rect.ymax()), level + 1);
                }
                else {
                    x.rt = insert(x.rt, p, new RectHV(x.p.x(), rect.ymin(), rect.xmax(), rect.ymax()), level + 1);
                }
            } else {
                if (p.y() < x.p.y()) {
                    x.lb = insert(x.lb, p, new RectHV(rect.xmin(), rect.ymin(), rect.xmax(), x.p.y()), level + 1);
                }
                else {
                    x.rt = insert(x.rt, p, new RectHV(rect.xmin(), x.p.y(), rect.xmax(), rect.ymax()), level + 1);
                }
            }
        }
        return x;
    }

    To:
    private Node insert(Node x, Point2D p, RectHV rect, int level) {
        if (x == null) {
            this.size++;
            return new Node(p, rect, null, null);
        } else {
            if (p.equals(x.p))
                return x;
            if (level % 2 == 0) {
                if (p.x() < x.p.x()) {
                    if(x.lb== null)
                        x.lb = insert(x.lb, p, new RectHV(rect.xmin(), rect.ymin(), x.p.x(), rect.ymax()), level + 1);
                    else
                        x.lb = insert(x.lb, p, x.lb.rect, level + 1);
                }
                else {
                    if(x.rt == null)
                        x.rt = insert(x.rt, p, new RectHV(x.p.x(), rect.ymin(), rect.xmax(), rect.ymax()), level + 1);
                    else
                        x.rt = insert(x.rt, p, x.rt.rect, level + 1);
                }
            } else {
                if (p.y() < x.p.y()) {
                    if(x.lb== null)
                        x.lb = insert(x.lb, p, new RectHV(rect.xmin(), rect.ymin(), rect.xmax(), x.p.y()), level + 1);
                    else
                        x.lb = insert(x.lb, p, x.lb.rect, level + 1);
                }
                else {
                    if(x.rt == null)
                        x.rt = insert(x.rt, p, new RectHV(rect.xmin(), x.p.y(), rect.xmax(), rect.ymax()), level + 1);
                    else
                        x.rt = insert(x.rt, p, x.rt.rect, level + 1);
                }
            }
        }
        return x;
    }


    This change could also solve below timing issue and get 100 scores:

    Test 3a-h: Perform range() queries after inserting n points into a 2d tree. The table gives
               the average number of calls to methods in RectHV and Point per call to range().

                   n      ops per second       intersects()      contains()        x()               y()
    ---------------------------------------------------------------------------------------------------------------
    => passed    10000     230973              49.4              31.1              50.1              12.1
    => passed    20000     198974              51.7              32.6              53.3              16.2
    => passed    40000     191390              63.9              39.3              63.1              14.1
    => passed    80000     147550              66.1              40.7              65.2              14.9
    => passed   160000      99792              69.0              42.5              70.9              20.4
    => passed   320000     107015              66.0              40.2              65.2              15.7
    => passed   640000     151866              71.0              43.3              70.7              19.2


    Total: 0/28 tests passed: Could not complete tests, which results in a reported score of 0.
    ================================================================
