1. At first I don't know what is the order to insert to red-black tree, and red-black tree requires the key and value.
   These make me so confusing, finally I tried input the whole Point2D as key could work fine, and the Point2D has default comparable interface.

2. for(Point2D p : this.rb.keys(lo, hi))
       if(p.x()>=rect.xmin() && p.x()<=rect.xmax()&& p.y()>=rect.ymin()&& p.y()<=rect.ymax())
            stack.push(p);

   This part need to verify whether each point is in the rectangle, otherwise all Point2D ymin <= y <= ymax is considered
   in the rectangle since the comparable of Point2D is consider y axis first.

3. private RectHV rect;    // the axis-aligned rectangle corresponding to this node

   The comment has a little hard to understand, my preliminary understanding for the rect is correct but my data
   structure is hard to be implemented and manipulated because I thought the Node is based on the Point but it's
   actually based on the Rectangle. Once a point is inserted, the rectangle is divided to 2 pieces, each piece is
   a new rectangle for the left node or right node.

   private static class Node {
      private Point2D p;      // the point
      private RectHV rect;    // the axis-aligned rectangle corresponding to this node
      private Node lb;        // the left/bottom subtree
      private Node rt;        // the right/top subtree
   }

4. Based on last item, consider once a point is added, the point will split the rectangle into 2, and:
    1) Calculate these 2 rectangles and store them to lb and rt Node? But what about lb and rt's point2D? Null? Trouble...
    2) Calculate the rectangle When insert the point2D. This seems to be sensible, so the Node is still based on the Point2D.
       The data structure seemed to be not hard to implement that construct it when do the insert() because you have the
       parent's information.

5. This is the code for contains() function, very tricky for go through the tree and return the root, this may some
   kind of use in Red-Black tree, I don't very understand the mechanism at that time.

       public boolean contains(Point2D p)            // does the set contain point p?
       {
           return this.get(this.root, p, 0)!= null;
       }

       private Point2D get(Node x, Point2D p, int level)
       {
           if (x==null) return null;
           if (x.p.equals(p)) return p;
           if (level % 2 == 0) {
               if (p.x() < x.p.x())
                   return get(x.lb, p, level+1);
               else
                   return get(x.rt, p, level+1);
           }
           else
           {
               if (p.y() < x.p.y())
                   return get(x.lb, p, level+1);
               else
                   return get(x.rt, p, level+1);
           }
       }

6. range() function:
   Basic idea of it is to check whether the current point is in the rectangle, and check whether the whole rectangle
   in on side of current point based on the level of current point, if yes then we can skip other side's search and
   save have time.

7. nearest() function:
   The implementation of this function is tricky, we can have 3 variables first, distance between current point and
   query point(d1), distance between the nearest point in query point side and query point (d2, this variable is get from
   recursion), distance between the line generated by current point's level and query point (d3).
   If  d2 is larger than d3, that means the points in other side could have a chance that get closer than the points in
   d2, so in the case we search the points in other side. If d2 is not larger than d3, we skip searching in other side,
   this will save us half of the time.
   After getting all distance, we return the nearest point.

8. Test 1c: insert distinct points; check size() and isEmpty() after each insertion
     * 1 random distinct points in a 1-by-1 grid
     * 10 random distinct points in a 8-by-8 grid
     * 20 random distinct points in a 16-by-16 grid
     * 10000 random distinct points in a 128-by-128 grid
     * 100000 random distinct points in a 1024-by-1024 grid


   WARNING: the time limit of 180 seconds was exceeded, so not all tests could be completed.

   This seems like I cannot use recursion in size() function like this:

    public int size()                             // number of points in the set
    {
        if(this.root == null)
            return 0;
        return size(this.root);
    }

    private int size(Node x) {
        if (x == null) return 0;
        else return 1 + size(x.lb) + size(x.rt);
    }

    I have to do some size addition when insert to a null node.

9. Test 1d: insert general points; check size() and isEmpty() after each insertion
     * 5 random general points in a 1-by-1 grid
       - failed after inserting point 5 of 5
       - student   size()    = 5
       - reference size()    = 4
       - student   isEmpty() = false
       - reference isEmpty() = false
       - sequence of points inserted:
         A  1.0 0.0
         B  1.0 1.0
         C  0.0 0.0
         D  0.0 1.0
         E  1.0 0.0

     * 10 random general points in a 4-by-4 grid
       - failed after inserting point 4 of 10
       - student   size()    = 4
       - reference size()    = 3
       - student   isEmpty() = false
       - reference isEmpty() = false
       - sequence of points inserted:
         A  0.75 0.5
         B  1.0 0.0
         C  0.0 0.75
         D  1.0 0.0

     * 50 random general points in a 8-by-8 grid
       - failed after inserting point 12 of 50
       - student   size()    = 12
       - reference size()    = 11
       - student   isEmpty() = false
       - reference isEmpty() = false
       - sequence of points inserted:
         A  0.625 0.5
         B  0.0 0.875
         C  0.875 0.375
         D  0.25 0.125
         E  0.5 0.5
         F  0.5 0.75
         G  1.0 1.0
         H  0.5 0.625
         I  0.75 0.75
         J  0.125 0.375
         K  0.75 0.0
         L  0.0 0.875

    After observation, it seems that when they did skipping when inserting a same point, but I still insert it, so that
    the size are different.

10. Test 3c: insert distinct points; check range() with random query rectangles
      * 2 random distinct points and random rectangles in a 2-by-2 grid
      * 10 random distinct points and random rectangles in a 4-by-4 grid
        - failed on trial 1 of 10000
        - query rectangle = [0.5, 1.0] x [0.0, 1.0]
        - sequence of points inserted:
          A  1.0 0.75
          B  0.75 0.75
          C  0.75 0.5
          D  0.25 0.75
          E  0.75 1.0
          F  0.5 0.5
          G  0.25 0.25
          H  1.0 0.25
          I  0.25 1.0
          J  0.25 0.5
        - student   range():  E F C B A
        - reference range():  A B C F E H

    It seems that the sequence is reverse since I use stack, I also miss one item.
    After replace the stack with queue, the "10 random distinct points and random rectangles in a 4-by-4 grid" pass,
    it's weird. And 1k is fail, problem still exists, and found no way to check.

    Solving problem 11 could solve the 1k random distinct points fail issue. This means my wheel making capability is
    still low. :(  |_|!

11. Description:
     Goal. Find all points in a query axis-aligned rectangle.
    ・Check if point in node lies in given rectangle.
    ・Recursively search left/bottom (if any could fall in rectangle).
    ・Recursively search right/top (if any could fall in rectangle).

    That's why it need call the intersects() and contains() function of RectHV. It check the whether the rectangles
    intersect first.

12. 